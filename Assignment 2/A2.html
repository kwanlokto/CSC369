
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <link rel="stylesheet" href="../../styles.css" type="text/css">

    <title>Assignment 2 - Page Tables and Replacement Algorithms</title>
    

<!--
  <link href="http://www.cdf.toronto.edu/~csc369h/winter/assets/themes/bootstrap/resources/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="http://www.cdf.toronto.edu/~csc369h/winter//assets/css/mystyle.css" rel="stylesheet">
-->
  
    <!--[if lt IE 9]>
      <script src="http://www.cdf.toronto.edu/~csc369h/winter/assets/themes/bootstrap/resources/respond/Respond.min.js"></script>
    <![endif]-->



    <div class="title">
        <h1>Assignment 2 - Page Tables and Replacement Algorithms  </h1>
</div>

<div class="navigation">
    <p><br/><br/><br/>
       <span class="links">
    <b>General Links</b>


<a href="http://www.cdf.toronto.edu/~csc369h/summer/index.shtml">Home page</a>
      <a href="http://www.cdf.toronto.edu/~csc369h/summer/content.shtml ">Lecture Notes</a>
      <a href="http://www.cdf.toronto.edu/~csc369h/summer/assignments.shtml ">Assignments</a>


<!--a href="https://mathlab.utsc.utoronto.ca/mybb/forumdisplay.php?fid=2">Discussion Board</a-->
      <!--a href="https://mathlab.utsc.utoronto.ca/courses/cscc69s15/exams.shtml">Exams</a-->
      <!--a href="https://mathlab.utsc.utoronto.ca/courses/cscc69s15/forms.shtml">Forms</a-->
      <!--a href="https://mathlab.utsc.utoronto.ca/mybb/forumdisplay.php?fid=10">Discussion Board</a>
      <a href="https://mathlab.utsc.utoronto.ca/courses/cscc69w16/docs/index.shtml">Documentation</a-->
      <!--a href="https://mathlab.utsc.utoronto.ca/courses/cscc69s15/cscc69/anon_feedback.html">Send Feedback</a-->


    </span>
    </p>



    </div>


  </head>

  <body>



<div class="content">

<p> <b>Due</b>: <strike></strike> July 9th, at 11:55pm</p>


<p>
<center>
<i>
It was such a relief to program in user mode for a change.
<br/>-- Linus Torvalds, to Git mailing list
</i>
</center>
</p>

<h2>Introduction</h2>

<p>For this assignment, we're going back to the realm of user mode programming.
Specifically, you will have to simulate the operation of page tables and
page replacement. As I keep saying: the way to gain a solid understanding of
the theory is by applying it in practice. 
</p>

<p>You have two tasks in this assignment, which will be based on a
virtual memory simulator.  The first task is to implement
virtual-to-physical address translation and demand paging using a
two-level page table.  The second task is to implement four different
page replacement algorithms: <tt>FIFO</tt>, <tt>Clock</tt>, <tt>exact
LRU</tt>, and <tt>OPT</tt>. 
</p>

<p>Before you start work, you should complete the set of readings about memory, 
if you haven't done so already:<br /> 
	
<ul>
	<li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-paging.pdf">Paging: Introduction</a>

</ul>


<h2>Requirements</h2>

<h3>Setup</h3>

<p> You will find the starter code <a href="starter.zip">HERE</a>.
It is your responsibility this time to add the code in your repository
and make sure that you submit all the necessary files!
</p>

<p>
<!--
<b>DO NOT MANUALLY CREATE A NEW DIRECTORY 'A2' IN YOUR REPOSITORY!</b>
An empty directory called 'A2' should be created for you automatically
when you log into MarkUs and go on your A2 link. Just do an svn update
to see the newly-created 'A2' directory in your repository.  
As usual, please make sure in advance that you can access your A2 directory,
to avoid last-minute surprises.
</p>
-->
<p>
Note that you may be generating some large trace files and must 
<b>NOT</b> commit any of the trace files that you generate to your repository 
or you will run into serious problems with disk quota.  
Most of the trace programs should be familiar to you from the exercise in week 6.  
We have added a blocked version of matrix multiply, <tt>blocked.c</tt> 
which should exhibit fewer page faults under at least some of the page 
replacement algorithms.  The Makefile shows you exactly how to compile 
and run the traces.  Note that it takes quite a while to run the trace collection.
</p>

<p> <em>Compile the trace programs and generate the traces.</em> </p>

<p>You may have noticed while doing the Exercise that the traces
generated by Valgrind are enormous since they contain every memory
reference from the entire execution. We have provided a program,
<tt>fastslim.py</tt> to reduce the traces by removing repeated
references to the same page that occur within a small window of each
other while preserving the important characteristics for virtual
memory simulation. (For example, a sequence of references to pages A
and B such as "ABABABABAB...AB" are reduced to just "AB".) The
<tt>runit</tt> script pipes the output of valgrind through this
program to create the reduced trace. If you wish, you can experiment
with <tt>fastslim.py</tt> to try omitting the instruction references
from the trace or using a smaller or larger window (<tt>fastslim.py
--help</tt>).  You may also want to create traces from other programs, 
and you will definitely want to create small manual traces for testing. 
</p>

<h3> Task 1 - Address Translation and Paging</h3>

<p><em>Implement virtual-to-physical address translation and demand paging using a two-level pagetable.
</em></p>

<p> The main driver for the memory simulator, <tt>sim.c</tt>, reads
memory reference traces in the format produced by the
<tt>fastslim.py</tt> tool from valgrind memory traces. For each line
in the trace, the program asks for the simulated physical address that
corresponds to the given virtual address by calling
<tt>find_physpage</tt>, and then reads from that location.  If the
access type is a write ("M" for modify or "S" for store), it will also
write to the location.  <em>You should read <tt>sim.c</tt> so that 
you understand how it works but you should not have to modify it.</em>.
</p>

<p> The simulator is executed as <tt>./sim -f &lt;tracefile&gt; -m
&lt;memory size&gt; -s &lt;swapfile size&gt; -a &lt;replacement
algorithm&gt; </tt> where memory size and swapfile size are the number
of frames of simulated physical memory and the number of pages that
can be stored in the swapfile, respectively. <em>The swapfile size
should be as large as the number of unique virtual pages in the trace,
which you should be able to determine easily.</em>  
</p>

<p>There are four main data structures that are used:
    <ol>
      <li> <tt>char *physmem</tt>: This is the space for our simulated
physical memory. We define a simulated page size (and hence frame
size) of SIMPAGESIZE and allocate SIMPAGESIZE * "memory size" bytes
for <tt>physmem</tt>.</li>
      
      <li><tt>struct frame *coremap</tt>: The <tt>coremap</tt> array
represents the state of (simulated) physical memory.  Each element of
the array represents a physical page frame.  It records if the
physical frame is in use and, if so, a pointer to the page table entry
for the virtual page that is using it.</li>

      <li><tt>pgdir_entry_t pgdir[PTRS_PER_PGDIR]</tt>: We are using a
two-level page table design; the top-level is referred to as the page
directory, which is represented by this array.  Each page directory
entry (<tt>pde_t</tt>) holds a pointer to a second-level page table
(which we refer to simply as page tables, for short).  We use the
low-order bit in this pointer to record whether the entry is valid or
not. The page tables are arrays of page table entries (pte_t), which
consist of a frame number if the page is in (simulated) physical
memory and an offset into the swap file if the page has been written
out to swap.  The format of a page table entry is shown here: <img
src="pte.jpg" alt="image of pte format" vspace=10px><br> Note that the
frame number and status bits share a word, with the low-order
PAGE_SHIFT bits (12 in our implementation) used for status (we only
have 4 status bits, but you can add more if you find it
useful). <em>Thus, for a given physical frame number (e.g. 7),
remember to shift it over to leave room for the status bits (e.g.,
<code>7 &lt;&lt; PAGE_SHIFT</code>) when storing into the pte and to
shift it back when retrieving a frame number from a pte (e.g., <code>
p-&gt;frame &gt;&gt; PAGE_SHIFT</code>)</em>.
      </li>

      <li><tt>swap.c</tt>: The swapfile functions are all implemented
in this file, along with bitmap functions to track free and used space
in the swap file, and to move virtual pages between the swapfile and
(simulated) physical memory.  <em>The <tt>swap_pagein</tt> and
<tt>swap_pageout</tt> functions take a frame number and a swap offset
as arguments. Be careful not to pass the frame field from a page table
entry (pte_t) directly, since that would include the extra status
bits.</em> The simulator code creates a temporary file in the current
directory where it is executed to use as the swapfile, and removes
this file as part of the cleanup when it completes. It does not,
however, remove the temporary file if the simulator crashes or exits
early due to a detected error.  <em>You must manually remove the
<tt>swapfile.XXXXXX</tt> files in this case.</em>
      </li>
    </ol>
</p>
<p> To complete this task, you will have to write code in <tt>pagetable.c</tt>.
Read the code and comments in this file -- it should be clear where 
implementation work is needed and what it needs to do.  The <tt>rand</tt>
replacement algorithm is already implemented for you, so you can test your
translation and paging functionality independently of implementing the 
replacement algorithms. 
</p>

<h3>Task 2</h3>

<p><em>Using the starter code, implement each of the four different 
page replacement algorithms: FIFO, exact LRU, CLOCK (with one ref-bit), OPT.</em> 
</p>

<p>You will find that you want to add fields to the <code>struct frame</code> 
for the different page replacement algorithms. You can add them in 
<code>pagetable.h</code>, but please label them clearly.</p>

<p>Once you're done implementing the algorithms, run all three programs 
from the provided  <tt>traceprogs</tt>, plus a fourth program of your 
choosing with interesting memory reference behaviour, using each of your 
algorithms (include rand as well). For each algorithm, run the programs 
on memory sizes 50, 100, 150, and 200. Use the data from these runs to 
create a set of tables that include the following columns.  
(Please label your columns in the following order,)
    <ul>
      <li>Hit rate</li>
      <li>Hit count</li>
      <li>Miss count</li>
      <li>Overall eviction count</li>
      <li>Clean eviction count</li>
      <li>Dirty eviction count</li>
    </ul>
</p>


<h3>Write up</h3>

<p>Include a file called  README.pdf that includes the following information.</p>

<ul>
    <li>The tables prepared in Task 2
    <li>One paragraph comparing the various algorithms in terms of the results you see in the tables. 
    <li>A second paragraph explaining the data you obtained for LRU as the size of memory increases.</li>
   
</ul>

<h2>Marking Scheme</h2>
<ul>
    <li>Task 1: 35%</li>
    <li>Task 2:
    <ul>
        <li>FIFO 5%</li>
        <li>LRU 10%</li>
        <li>CLOCK 10%</li>
        <li>OPT 15%<br />
            (must be able to run all traces in a reasonable amount of time)</li>
    </ul>
    </li>
    <li>Tables 5%</li>
    <li>Comparison paragraph 5% </li>
    <li>LRU description 5%</li>
    <li>Program readability and organization 10%</li>
</ul>

<h2>Submission</h2>

must be submitted through markus

<!--p> you have to submit one tar file named "A2.tar.gz" that includes all the A)src files(simulator code) B) README.pdf C) 
Additionally, you must add and commit an INFO.txt file, which contains 	the following for all team members:
	<ul>
	<li>your name</li> 
	<li>your CDF ID</li>
	</ul>
	Aside from this, please feel free to describe problems you've encountered, what isn't 
	fully implemented (or doesn't work fully), any special design decisions you've taken, etc.
</p-->

<p>
	Make sure your code compiles without any errors or warnings.<br/>
	<b>Code that does not compile will receive zero marks!</b>
</p>
<!--
<p>
As with Assignment 1, after you have committed everything to your repo, but before your 
submission can be considered complete:
  <ol>
    <li>create an empty temporary directory in your cdf account (not in a subdirectory of your repo)</li>
    <li>check out a copy of your repository for this assignment</li>
    <li>verify that your README and INFO.txt files are included
    <li>run <tt>make</tt> and ensure that you are able to build <tt>sim</tt> without 
any errors or warnings (This is an excellent way to verify that all files have been committed to the repo.)</li>
    <li>run a few tests using the same traces you used to create the tables in your README, 
to ensure that your code behaves as you expect</li>
    <li>congratulate yourself and enjoy a well-earned break, knowing that your strategy 
and hard work will pay off!</li>
  </ol>
</p> -->

  </div>
</div>


      <hr>
   </div>

    

  </body>
</html>

